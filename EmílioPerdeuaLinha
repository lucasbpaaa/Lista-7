#Question 2:
def merge_intervals(lista):
    lista.sort()
    new_list = []
    i = 0
    while i < len(lista):
        new_interval = lista[i][:]
        while i < len(lista) - 1 and new_interval[1] >= lista[i + 1][0]:
            new_interval[1] = max(new_interval[1], lista[i + 1][1])
            i += 1  
        new_list.append(new_interval)
        i += 1
    return new_list

merge_intervals([[1, 2], [2, 3], [10, 12], [8, 9]])


#Question 3: 
def missing_int(lista):
    right= 0
    left = len(lista) - 1
    while right <= left:
        mid = (right + left) // 2
        
        #Vamos verificar se o valor ausente está à esquerda ou à direita do ponto médio
        if lista[mid] == lista[0] + mid:
            right = mid + 1
        else:
            left = mid - 1
    
    # No final, left será o índice onde a transição ocorre, então o primeiro faltante é nums[0] + left
    return lista[0] + right
print(missing_int([2, 3, 4, 5, 6, 8]))


#Question 4:
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Linked_list:
    def __init__(self, lista = None):
        self.head = Node(lista[0])
        self.size = 0
        current_node = self.head
        for element in lista[1:]:
            created_node = Node(element)
            current_node.next = created_node
            current_node = created_node
            self.size += 1
    def inversed_list(self):
        current_node = self.head
        invert = []
        while current_node is not None:
            invert.insert(0, current_node.data)
            current_node = current_node.next
        return invert
        
    def is_palindrome(self):
        original_list = []
        current_node = self.head
        while current_node is not None:
            original_list.append(current_node.data)
            current_node = current_node.next
        
        reversed_list = self.inversed_list()
        return original_list == reversed_list
      

Linked_list([1, 2, 3, 3, 2, 1]).is_palindrome()
